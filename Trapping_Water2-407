struct Cell {
    int h, r, c;
};
struct Cmp {
    bool operator()(const Cell &a, const Cell &b) const {
        return a.h > b.h; // min-heap by height
    }
};

class Solution {
public:
    int trapRainWater(vector<vector<int>>& height) {
        int m = height.size();
        if (m == 0) return 0;
        int n = height[0].size();
        if (n == 0) return 0;

        vector<vector<bool>> vis(m, vector<bool>(n, false));
        priority_queue<Cell, vector<Cell>, Cmp> pq;

        // push all boundary cells
        for (int i = 0; i < m; ++i) {
            pq.push({height[i][0], i, 0}); vis[i][0] = true;
            if (n > 1) { pq.push({height[i][n-1], i, n-1}); vis[i][n-1] = true; }
        }
        for (int j = 1; j < n-1; ++j) {
            pq.push({height[0][j], 0, j}); vis[0][j] = true;
            if (m > 1) { pq.push({height[m-1][j], m-1, j}); vis[m-1][j] = true; }
        }

        int dirs[4][2] = {{1,0},{-1,0},{0,1},{0,-1}};
        long long water = 0;

        while (!pq.empty()) {
            Cell cur = pq.top(); pq.pop();
            for (auto &d : dirs) {
                int nr = cur.r + d[0], nc = cur.c + d[1];
                if (nr < 0 || nr >= m || nc < 0 || nc >= n) continue;
                if (vis[nr][nc]) continue;
                vis[nr][nc] = true;
                if (height[nr][nc] < cur.h) {
                    water += (long long)cur.h - height[nr][nc];
                    pq.push({cur.h, nr, nc}); // neighbor now has effective height cur.h
                } else {
                    pq.push({height[nr][nc], nr, nc});
                }
            }
        }
        return (int)water;
    }
};
